---
title: Network Tokens
abbrev: networktokens
docname: draft-yiakoumis-network-tokens-00
date: 2020-04-13
category: info

ipr: trust200902
area: General
workgroup: TBD
keyword: Internet-Draft

stand_alone: yes
pi: [toc, sortrefs, symrefs]

author:
 -
    ins: Y. Yiakoumis
    name: Yiannis Yiakoumis
    organization: Selfie Networks, Inc
    email: yiannis@selfienetworks.com

normative:
  RFC7519:
  RFC7515:
  RFC7516:
  RFC8152:
  RFC8392:
  RFC5226:

informative:
  RFC2119:

--- abstract

Network Tokens is a method to securely transfer claims between endpoints and a network to drive or assist network policy. They are inserted by endpoints in existing protocols, interpreted by trusted networks, and may be signed or encrypted to meet security and privacy requirements. Network Tokens can be represented as JSON Web Tokens, CBOR Web Tokens, or other available formats. They can be used to expose and access a variety of network services such as firewall whitelists, QoS, and zero-rating services.

--- middle

# Introduction        {#intro}

The JSON Web Token (JWT) [RFC7519] and CBOR Web Token (CWT) [RFC8392] are  standardized security token formats that have found use in OAuth 2.0, OpenID Connect, and Internet of Things deployments, among other applications. JWT and CWT use JSON Object Signature and Encryption (JOSE) and COBR Object Signature and Encryption (COSE) technologies to secure the contents of tokens, which essentially are a set of claims represented in JSON or CBOR. 

This specification motivates and describes the use of tokens - named network tokens - as a method to securely transfer claims between endpoints and a network to drive and/or assist network policy. Network tokens are inserted by endpoints in existing protocols, interpreted by trusted networks, and may be signed or encrypted to meet a variety of security and privacy requirements. They can be encoded as JSON Web Tokens, CBOR Web Tokens, or other available formats.  Network tokens can be used to expose and access a variety of network services such as firewall whitelists, QoS, and zero-rating services.

# Terminology

* End Users: We use the term "end user" to broadly characterize a role that has control over an endpoint. This can be an individual user, an enterprise, an Operating System, or an application. 

# Motivation
* Discuss existing alternatives through DiffServ and DPI
* Requirements from different perspectives (network operator, regulator, app developer, user)


# Network Token Overview

A network token is a small piece of data that end users attach to their packets to access a whitelist-based network service. As packets flow through the network, intermediate nodes detect tokens, interpret them, and apply the desired service to the packets that carry them (and possibly to all other packets from the same flow). 

Network tokens are always interpreted by a network operator. Token generation depends on the use case and trust relationship between the different entities involved. For example, tokens might be generated by the network who distributes it to eligible end-users on-demand. Alternatively, the operator can enable users to generate multiple tokens themselves, or application providers might generate tokens and tell operators how to interpret them. 

To prevent unauthorized third-parties from replaying, spoofing, or interpreting a token, tokens may be signed and encrypted, in ways described below. Network tokens can use custom or existing representation formats, like JWT {{RFC7515}} or CWT {{RFC7516}}. Section XX discusses example tokens for specific usecases.

Network tokens do not dictate a dedicated header or protocol to be inserted. Instead, they are incorporated as options and extensions into a variety of existing protocols. For example, network tokens can be carried as TLS Client and Server Hello extensions during a TLS handshake, as IPv6 destination or Hop by Hop Options, or as attributes during a STUN-enabled flow setup. Network tokens are largely opaque to the protocols that carry them. Section XX discusses implementation details for inserting tokens, and Section XX lists recommended IANA registry changes for TLS, STUN, and IPv6. 

The distribution of tokens is out of scope for this document. 

# Contents and Representation

The contents of a network token fulfil three main goals:

* communicate the desired information between an endpoint and the network (e.g., the name of an application, or a user key to request low-latency services)
* prevent unauthorized parties from replaying or using these tokens to inadvertently access network services (e.g., through the use of timestamps, expiration time, nonces)
* digitally sign and/or encrypt a token to meet privacy and security requirements

Network operators can define their own structure to represent tokens, for example through pre-defined byte sequences or a list of TLV-encoded fields. Alternatively, tokens can use JOSE and COSE technologies for representation, as they already provide a framework to securely communicate information between different entities. The actual representation and contents of a token should take into consideration the capabilities of the network to process them (i.e, what cryptographic functionality can the network support), length in terms of header space, and requirements for integrity protection, privacy preservation, and attack scenarios. 

Examples in this document will use JWT to represent tokens, as they are well understood by the community and easily read by humans. Translation to a different representation format should be straight forward. 

## Network Token Common fields

Network tokens can have arbitrary fields (or claims). The fields defined below, while not mandatory, provide a starting point for a set of useful, interoperable fields. Network services using network tokens should define which specific fields they use and whether they are required or optional. Several of the fields listed below are already registered as part of JWT and CWT specifications, while others are specific for network tokens. 

### 'iss' (Issuer) field

The "iss" (issuer) field identifies the principal that issued the
token.  For example, the issuer might be the name of the network operator that offers the service of interest. The processing of this claim is generally application specific.

### "sub" (Subject) field

The "sub" (subject) field identifies the principal that is the
subject of the token.  This could be a subscriber id, or the name of an application. The subject value MUST either be scoped to be
locally unique in the context of the issuer or be globally unique.
The processing of this claim is generally application specific. 

### "exp" (Expiration Time) field

The "exp" (expiration time) field identifies the expiration time on
or after which the token MUST NOT be accepted for processing. The
processing of the "exp" field requires that the current date/time
MUST be before the expiration date/time listed in the "exp" claim. Implementers MAY provide for some small leeway, usually no more than
a few minutes, to account for clock skew. The "exp" field can be used to reduce the probability of replay attacks, restrict service access to a certain period, or to force users to refresh authentication credentials. 

### "iat" (Issued At) field

The "iat" (issued at) field identifies the time at which the token was
issued or generated.  This field can be used to determine the age of the token, and can be used along or instead of the "exp" field.

### "nti" field (Network Token ID) field

The "nti" field provides a nonce-like value for the token. The identifier value MUST be assigned in a manner that ensures that there is a negligible probability that the same value will be accidentally assigned to a different data object; if the application uses multiple issuers, collisions MUST be prevented among values produced by different issuers as well.  The "nti" field can be used to prevent the token from being replayed.

### "bip" field (Bound IP) field

The "bip" (Bound IP) field bounds the use of the token to a specific IP address. This can prevent third parties from reusing the token in a different context.  

## Network Token Format

A token consists of the following fields (Figure X):

* Reflect Type (4-bits): Indicates reflection properties for the token.
    * 0x0: Token is inserted by the origin of this flow. No reflection needed. 
    * 0x1: Token is inserted by the origin of this flow. Reflect at receiver.
    * 0x2: Reflected token.
    * 0x3-0xf: Reserved

* Token Descriptor ID (28-bits): An ID that helps the network decide whether and how to interpret tokens. Descriptor IDs are registered in the "Token Descriptor ID" registry (MSB = 0) or private (MSB equals 1). For private descriptor IDs, the definer of the value needs to take reasonable precautions to make sure they are in control of the part of the namespace they use (e.g., by using a OUI prefix). A token descriptor might just indicate that the token payload is a JWT, or point to a structure that holds keys and other information to interpret a token. 

* Token Payload: Depending on the application, the token payload might be a self-contained JWT or CWT (as plaintext, signed, or encrypted), a set of TLV-encoded values, or has its own custom format. 

The length of the token is arbitrary, but must follow the limitations imposed by the protocol it is encapsulated. For example, if the token is carried as an IPv6 hop-by-hop option, the total length of the token cannot exceed 256 bytes. 

~~~~

                      0         1         2        3                
                      0123456789012345678901245678901               
                     +-------------------------------+              
                     |      token descriptor id      |              
                     +-------------------------------+              
                     |                               |              
                     |                               |              
                     |         token payload         |              
                     |                               |              
                     |                               |              
                     +-------------------------------+

~~~~

# Example Network Tokens

This section discusses example network tokens and how they can serve specific use cases. 

## Firewall Whitelist Token

A firewall token can be used to whitelist traffic from trusted applications. 

The following example verifies that a network flow is coming from "The Godfather App". 

The token payload is encoded as a JWT, and encapsulated as a TLS Extension attached in a Server Hello Message.

The Reflect Type is 0x00 (i.e., this is the origin flow and peers should not reflect it), with the expectation that firewalls can setup appropriate state for the reverse flow as well. The Token Descriptor ID is 0x03, which might represent a registered value for firewall tokens. 

The JWT encodes the following object. 

The header of the JWT has the following fields:

~~~~

{"alg":"ES256", "kid":"N6fr1MDrEuu1eXRkFbcpX4WY62SKN7TKrhYf9PfJEd8"}

~~~~

The token is signed using the Elliptic Curve Digital Signature Algorithm, and the public key can be looked-up in a pre-defined database using the "kid" thumbprint. 

The JWT payload has the following fields:

~~~
{"sub":"The Godfather App", "iat":1588116732, "exp":1588117732,"bip":"140.54.35.194"}
~~~

The token is created by the app provider. It states that this flow originates from "The Godfather App", along with the time that it was created and when it expires. The token is signed with the app provider's public key, and any network can verify this through the attached signature. The token is also bound to a specific IP address, and therefore cannot be reused in a different context. For example, the application provider could configure all exit gateways to attach a token for all outgoing flows.  

## Low-latency Token

A low-latency token is used to access a custom QoS SLA from a mobile operator tailored for video communications. This is an application-agnostic service, i.e., users can use it for any traffic they want. 

The token payload is encoded as a JWT, and can be inserted to STUN (as STUN attributes) or IPv6 packets (as IPv6 Hop-by-Hop extension header). 

The Reflect Type is 0x1, i.e., peers should reflect the token to setup state for the reverse flow. The Token Descriptor ID is 0x01, stating that the token payload is a JWT object. 

The header of the JWT has the following fields:

~~~~
{'alg':'dir','enc':"A256CBC-HS512", 'app_id':14098715987234}
~~~~

The token is generated by the operator, and signed with the AES-256 algorith, using a customer-specific symmetric key. The app_id points is a local identifier, that the operator has associated with its own services. 


The payload of the token has the following fields, requesting for low-latency treatment, and bounding the start and end time of the token. It also has a unique identifier to allow revocation. 

~~~~
{'srv':'lowlatency', 'nti': 5871234, iat':1588116732, 'exp':1588203132}
~~~~

Each token is valid for 24 hours. As the encryption key is bound to a specific user, it cannot be used by another context. The Operating System (or an agent) in the user's device can request a token, and grant it to specific applications based on a user's request. Users can revoke access by telling an operator to blacklist the nti associated with this token. 

Besides accessing a low-latency service, this token serves two requirements: 
* it is application agnostic and can be used for any application a user wants
* it preserves privacy. There is no indication about specific applications, and no identifier that can be linked to a user. 

# Network Tokens and Encapsulating protocols

## Network Tokens as a TLS Extension

## Network Tokens as a STUN Attribute

## Network Tokens as an IPv6 Hop-by-Hop Extension Header



# Implementation Considerations

Things to discuss

* Token --> DiffServ Mapping
* Token reflect and reverse flow
* Not every node needs to interpret tokens
* Multiple networks / multiple recipients

# Security Considerations

As any cryptographic application, it is important for users of network tokens applications to protect asymmetric private and symmetric secret keys,  and employ countermeasures to various attacks. 

The security of network tokens relies upon on the protections offered by the underlying signing and encryption technologies. It is therefore recommended that implementations of network tokens use existing and well-understood cryptographic frameworks (like JOSE and COSE) to protect tokens, or careful consider security implications if they provide their own format. 

Network tokens may require processing in software, as current hardware platforms do not support cryptographic capabilities. This might impose a security risk and exposure to an attack, as traffic could be diverted towards the slow path, and in return degrade the overall performance of a node. It is recommended that implementations adequately account for such scenarios, either by setting a rate-limit to packets that go through a slow path or ensuring that the overall functionality is not affected. 


# IANA Considerations

## Token Descriptor ID Registry

This section establishes the IANA "Network Token Descriptor ID" registry for token descriptors. The registry records the descriptor ID and a reference to the specification that defines it. 

Values are registered on a Specification Required {{RFC5226}} basis after a three-week review period, on the advice of one or more Designated Experts. However, to allow for the allocation of values prior to publication, the Designated Experts may approve registration once they are satisfied that such a specification will be published. 

Within the review period, the Designated Experts will either approve
or deny the registration request, communicating this decision to the
review list and IANA.  Denials should include an explanation and, if
applicable, suggestions as to how to make the request successful.

Criteria that should be applied by the Designated Experts includes
determining whether the proposed registration duplicates existing
functionality, whether it is likely to be of general applicability or
whether it is useful only for a single application, and whether the
registration description is clear.

### Initial Registry Contents

* Token Descriptor ID: 0x1
* Description: Token is represented as a JSON Web Token
* Specificaton Document(s): This document.

* Token Descriptor ID: 0x2
* Description: Token is represented as a Concise Binary Representation Object
* Specification Document(s): This document

## IPv6 Hop-By-Hop options registration

This section registers the value 0x0F as a IPv6 Hop-By-Hop and Destination Option for network tokens. 

* Hex Value: 0x1F
* Binary Value: 0x00011111
* Description: Network Token
* Reference: This document

## TLS ExtensionType Registry

This section registers the value 57 as a TLS Extension Type for network tokens.

* Value: 57
* Description: Network Token
* Reference: This document

## STUN Attributes Registry

This section registers the value 0x001F as a STUN attribute for network tokens. 

* Value: 0x001F
* Description: Network Token
* Reference: This document

